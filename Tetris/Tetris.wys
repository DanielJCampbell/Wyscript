type Block is {int type, int rotation, int x, int y} //Note x and y always track the leftmost and topmost piece of the block

type Board is [[bool]]

type Game is {Block current, Block next, Board board}

native void setGame(Game g)
native Game getGame()
native int rand()
native void gameOver()

void init():
    Game g = {current:makeBlock(), next:makeBlock(), board:makeBoard()}
    setGame(g)

Block makeBlock():
    int rotation = 0
    int x = 4
    int y = 0
    int type = rand()
    
    switch (type):
        case 0:
            y = 1
        case 1:
            y = 3
        case 2:
            x = 3
            y = 2
        case 3:
            y = 2
        case 4:
            x = 3
            y = 1
        case 5:
            y = 1
        case 6:
            y = 1
    return {type:type, rotation:rotation, x:x, y:y}

Board makeBoard():
    Board board = []
    [bool] col = []
    
    for i in 0..10:
        col = []
        for j in 0..20:
            col = col ++ [false]
        board = board ++ col
    return board

//Called every 'tick' of gameplay, or when the player holds down space - moves the block down one and handles any collisions that occur
void update():
    Game g = getGame();
    Board board = g.board
    Block block = g.current
    
    block.y = block.y+1
    if hasCollided(board, block, true):
        g = getGame() //Need to refresh game, as board state may have changed
        g.current = g.next
        g.next = makeBlock()
        if hasCollided(g.board, g.current, false):  //there is no room for the new block, so gameover
            gameOver()
            return
    else:
        g.current = block
    setGame(g)
    
void moveLeft():
    Game g = getGame()
    Block b = g.current
    b.x = b.x-1
    if (hasCollided(g.board, b, false) || b.x < 0):
        b.x = b.x+1
    g.current = b
    setGame(g)

void moveRight():
    Game g = getGame()
    Block b = g.current
    b.x = b.x+1
    if (hasCollided(g.board, b, false) || b.x > 9):
        b.x = b.x-1
    g.current = b
    setGame(g)

void rotateLeft():
    Game g = getGame()
    Block b = g.current
    [[bool]] oldPieces = calculatePieces(b)
    int oldX = b.x
    int oldY = b.y
    b.rotation = b.rotation - 90
    if b.rotation < 0:
        b.rotation = 360 + b.rotation
    b = changePos(b, oldPieces, calculatePieces(b))
    if (hasCollided(g.board, b, false):
        b.x = oldX
        b.y = oldY
        b.rotation = b.rotation + 90
        if b.rotation >= 360:
            b.rotation = b.rotation - 360
    g.current = b
    setGame(g)

void rotateRight():
    Game g = getGame()
    Block b = g.current
    [[bool]] oldPieces = calculatePieces(b)
    int oldX = b.x
    int oldY = b.y
    b.rotation = b.rotation + 90
    if b.rotation >= 360:
        b.rotation = b.rotation - 360
    b = changePos(b, oldPieces, calculatePieces(b))
    if (hasCollided(g.board, b, false):
        b.x = oldX
        b.y = oldY
        b.rotation = b.rotation - 90
        if b.rotation < 0:
            b.rotation = 360 + b.rotation
    g.current = b
    setGame(g)

//Calculates the piece matrix for a given block - this is a 4x4 list of booleans, where true indicates that cell is occupied
[[bool]] calculatePieces(Block b):
    [[bool]] pieces = []
    switch (b.type):
        case 0:
            pieces = pieces ++ [[true, true, false, false]]
            pieces = pieces ++ [[true, true, false, false]]
            pieces = pieces ++ [[false, false, false, false]]
            pieces = pieces ++ [[false, false, false, false]]
        case 1:
            if(b.rotation == 0 || b.rotation == 180):
                pieces = pieces ++ [[false, false, false, false]]
                pieces = pieces ++ [[true, true, true, true]]
                pieces = pieces ++ [[false, false, false, false]]
                pieces = pieces ++ [[false, false, false, false]]
            else:
                pieces = pieces ++ [[false, true, false, false]]
                pieces = pieces ++ [[false, true, false, false]]
                pieces = pieces ++ [[false, true, false, false]]
                pieces = pieces ++ [[false, true, false, false]]
        case 2:
            switch (b.rotation):
                case 0:
                    pieces = pieces ++ [[false, false, false, false]]
                    pieces = pieces ++ [[false, false, true, false]]
                    pieces = pieces ++ [[true, true, true, false]]
                    pieces = pieces ++ [[false, false, false, false]]
                case 90:
                    pieces = pieces ++ [[false, true, true, false]]
                    pieces = pieces ++ [[false, false, true, false]]
                    pieces = pieces ++ [[false, false, true, false]]
                    pieces = pieces ++ [[false, false, false, false]]
                case 180:
                    pieces = pieces ++ [[true, true, true, false]]
                    pieces = pieces ++ [[true, false, false, false]]
                    pieces = pieces ++ [[false, false, false, false]]
                    pieces = pieces ++ [[false, false, false, false]]
                case 270:
                    pieces = pieces ++ [[true, false, false, false]]
                    pieces = pieces ++ [[true, false, false, false]]
                    pieces = pieces ++ [[true, true, false, false]]
                    pieces = pieces ++ [[false, false, false, false]]
        case 3:
            switch (b.rotation):
                case 0:
                    pieces = pieces ++ [[true, true, true, false]]
                    pieces = pieces ++ [[false, false, true, false]]
                    pieces = pieces ++ [[false, false, false, false]]
                    pieces = pieces ++ [[false, false, false, false]]
                case 90:
                    pieces = pieces ++ [[true, true, false, false]]
                    pieces = pieces ++ [[true, false, false, false]]
                    pieces = pieces ++ [[true, false, false, false]]
                    pieces = pieces ++ [[false, false, false, false]]
                case 180:
                    pieces = pieces ++ [[false, false, false, false]]
                    pieces = pieces ++ [[true, false, false, false]]
                    pieces = pieces ++ [[true, true, true, false]]
                    pieces = pieces ++ [[false, false, false, false]]
                case 270:
                    pieces = pieces ++ [[false, false, true, false]]
                    pieces = pieces ++ [[false, false, true, false]]
                    pieces = pieces ++ [[false, true, true, false]]
                    pieces = pieces ++ [[false, false, false, false]]
        case 4:
            switch (b.rotation):
                case 0:
                    pieces = pieces ++ [[true, false, false, false]]
                    pieces = pieces ++ [[true, true, false, false]]
                    pieces = pieces ++ [[true, false, false, false]]
                    pieces = pieces ++ [[false, false, false, false]]
                case 90:
                    pieces = pieces ++ [[false, false, false, false]]
                    pieces = pieces ++ [[false, true, false, false]]
                    pieces = pieces ++ [[true, true, true, false]]
                    pieces = pieces ++ [[false, false, false, false]]
                case 180:
                    pieces = pieces ++ [[false, false, true, false]]
                    pieces = pieces ++ [[false, true, true, false]]
                    pieces = pieces ++ [[false, false, true, false]]
                    pieces = pieces ++ [[false, false, false, false]]
                case 270:
                    pieces = pieces ++ [[true, true, true, false]]
                    pieces = pieces ++ [[false, true, false, false]]
                    pieces = pieces ++ [[false, false, false, false]]
                    pieces = pieces ++ [[false, false, false, false]]
        case 5:
            if (b.rotation == 0 || b.rotation == 180):
                pieces = pieces ++ [[true, false, false, false]]
                pieces = pieces ++ [[true, true, false, false]]
                pieces = pieces ++ [[false, true, false, false]]
                pieces = pieces ++ [[false, false, false, false]]
            else:
                pieces = pieces ++ [[false, true, true, false]]
                pieces = pieces ++ [[true, true, false, false]]
                pieces = pieces ++ [[false, false, false, false]]
                pieces = pieces ++ [[false, false, false, false]]
        case 6:
            if (b.rotation == 0 || b.rotation == 180):
                pieces = pieces ++ [[false, true, false, false]]
                pieces = pieces ++ [[true, true, false, false]]
                pieces = pieces ++ [[true, false, false, false]]
                pieces = pieces ++ [[false, false, false, false]]
            else:
                pieces = pieces ++ [[true, true, false, false]]
                pieces = pieces ++ [[false, true, true, false]]
                pieces = pieces ++ [[false, false, false, false]]
                pieces = pieces ++ [[false, false, false, false]]
    return pieces

//Given a block, its old piece matrix and its new piece matrix, determine the change in position of the block
//and return a block with the new x and y
Block changePos(Block b, [[bool]] old, [[bool]] new):
    int oldX = 4
    int oldY = 4
    int newX = 4
    int newY = 4
    
    for i in 0..3:
        for j in 0..3:
            if old[i][j]:
                if i < oldX:
                    oldX = i
                if j < oldY:
                    oldY = j
            if new[i][j]:
                if i < newX:
                    newX = i
                if j < newY
                    newY = j
    int xDiff = newX - oldX
    int yDiff = newY - oldY
    b.x = b.x + xDiff
    b.y = b.y + yDiff
    return b

//Checks whether the block collides with any existing debris on the board
//if isUpdate is true, on a collision will add that block to the board and will clear any full lines found
bool hasCollided(Board board, Block block, bool isUpdate):
    [[bool]] pieces = calculatePieces(block)
    bool valid = true
    for i in block.x..(block.x+4):
        for j in block.y..(block.y+4):
            if (board[i][j] && pieces[i-block.x][j-block.y]):
                if !(isUpdate):
                    return true
                valid = false
    if valid:
        return true
    block.y = block.y - 1
    for i in block.x..(block.x+4):
        for j in block.y..(block.y+4):
            if pieces[i-block.x][y-block.y]:
                board[i][j] = true
    board = clearLines(board)
    Game g = getGame()
    g.board = board
    setGame(g)

Board clearLines(Board board):
    bool line = true
    for j in 0..20:
        line = true
        for i in 0..10:
            if !(board[i][j]):
                line = false
        if line:
            for i in 0..10:
                board[i][j] = false
    return board
